Tornado版本为4.4.2

## 0x01. 一般启动代码示例

代码片段1
```
    import tornado.ioloop
    import tornado.web

    application = web.Application([
        (r"/", MainPageHandler),
    ])
    http_server = httpserver.HTTPServer(application)
    http_server.listen(8080)
    ioloop.IOLoop.current().start()
```

## 0x02. 开始分析

### 一. application的创建

tornado.web.Application类的__init__方法如下：
```
    def __init__(self, handlers=None, default_host=None, transforms=None,
                 **settings):
        if transforms is None:
            self.transforms = []
            if settings.get("compress_response") or settings.get("gzip"):
                self.transforms.append(GZipContentEncoding)
        else:
            self.transforms = transforms
        self.default_host = default_host
        self.settings = settings
        self.ui_modules = {'linkify': _linkify,
                           'xsrf_form_html': _xsrf_form_html,
                           'Template': TemplateModule,
                           }
        self.ui_methods = {}
        self._load_ui_modules(settings.get("ui_modules", {}))
        self._load_ui_methods(settings.get("ui_methods", {}))
        if self.settings.get("static_path"):
            path = self.settings["static_path"]
            handlers = list(handlers or [])
            static_url_prefix = settings.get("static_url_prefix",
                                             "/static/")
            static_handler_class = settings.get("static_handler_class",
                                                StaticFileHandler)
            static_handler_args = settings.get("static_handler_args", {})
            static_handler_args['path'] = path
            for pattern in [re.escape(static_url_prefix) + r"(.*)",
                            r"/(favicon\.ico)", r"/(robots\.txt)"]:
                handlers.insert(0, (pattern, static_handler_class,
                                    static_handler_args))

        if self.settings.get('debug'):
            self.settings.setdefault('autoreload', True)
            self.settings.setdefault('compiled_template_cache', False)
            self.settings.setdefault('static_hash_cache', False)
            self.settings.setdefault('serve_traceback', True)

        self.wildcard_router = _ApplicationRouter(self, handlers)
        self.default_router = _ApplicationRouter(self, [
            Rule(AnyMatches(), self.wildcard_router)
        ])

        # Automatically reload modified modules
        if self.settings.get('autoreload'):
            from tornado import autoreload
            autoreload.start()
```
1. 请求输出内容的转码(后面进行分析 TODO)
```
    if transforms is None:
        self.transforms = []
        if settings.get("compress_response") or settings.get("gzip"):
            self.transforms.append(GZipContentEncoding)
    else:
        self.transforms = transforms
```
2. 加载自定义的UIModule和UIMethod

```
    self._load_ui_modules(settings.get("ui_modules", {}))
    self._load_ui_methods(settings.get("ui_methods", {}))
```
3. 静态资源路径配置
4. 路由配置
```
    self.wildcard_router = _ApplicationRouter(self, handlers)
    self.default_router = _ApplicationRouter(self, [
        Rule(AnyMatches(), self.wildcard_router)
    ])
```

至此，可得到Application的基本类图：

![Application Class](application_class.png)

### 二 HTTPServer的创建和监听端口

#### 1. HTTPServer的创建

HTTPServer类，是TCPServer、Configurable、httputil.HTTPServerConnectionDelegate的子类声明如下：
```
    class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate):
```
由于是Configurable的子类，创建的实例由类方法configurable_base、configurable_default和实例方法initialize共同决定，后面再作具体分析。在HTTPServer类中这些方法为：
```

def initialize(self, request_callback, no_keep_alive=False, io_loop=None,
               xheaders=False, ssl_options=None, protocol=None,
               decompress_request=False,
               chunk_size=None, max_header_size=None,
               idle_connection_timeout=None, body_timeout=None,
               max_body_size=None, max_buffer_size=None):
    self.request_callback = request_callback
    self.no_keep_alive = no_keep_alive
    self.xheaders = xheaders
    self.protocol = protocol
    self.conn_params = HTTP1ConnectionParameters(
        decompress=decompress_request,
        chunk_size=chunk_size,
        max_header_size=max_header_size,
        header_timeout=idle_connection_timeout or 3600,
        max_body_size=max_body_size,
        body_timeout=body_timeout)
    TCPServer.__init__(self, io_loop=io_loop, ssl_options=ssl_options,
                       max_buffer_size=max_buffer_size,
                       read_chunk_size=chunk_size)
    self._connections = set()

@classmethod
def configurable_base(cls):
    return HTTPServer

@classmethod
def configurable_default(cls):
    return HTTPServer
```
#### 2.监听端口
```
http_server.listen(8080)
```
listen方法在类TCPServer中实现：
```
# tcpserver.TcpServer
def listen(self, port, address=""):
    """Starts accepting connections on the given port.

    This method may be called more than once to listen on multiple ports.
    `listen` takes effect immediately; it is not necessary to call
    `TCPServer.start` afterwards.  It is, however, necessary to start
    the `.IOLoop`.
    """
    sockets = bind_sockets(port, address=address)
    self.add_sockets(sockets)
```
其中，bind_sokets是 tornado.netutil中的方法,创建监听套节字绑定到给定的端口和地址，并返回创建的所有套接字。


#### self.add_sockets(sockets)